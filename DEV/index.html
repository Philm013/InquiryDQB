<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>InquiryDQB</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#f8fafc">
    <meta name="apple-mobile-web-app-capable" content="yes">
    
    <!-- Tldraw CSS -->
    <link rel="stylesheet" href="https://esm.sh/tldraw@3.5.0/tldraw.css" />
    
    <!-- Libraries -->
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    
    <!-- Import Map -->
    <script type="importmap">
    { "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "tldraw": "https://esm.sh/tldraw@3.5.0?external=react,react-dom",
        "peerjs": "https://esm.sh/peerjs@1.5.2?bundle-deps"
    }}
    </script>

    <style>
        :root {
            /* Light Theme Variables */
            --primary: #6366f1; --primary-hover: #4f46e5;
            --bg-body: #f8fafc; --bg-card: #ffffff; 
            --text-main: #0f172a; --text-muted: #64748b;
            --c-notice: #bae6fd; --c-wonder: #fbcfe8; --c-idea: #e9d5ff; --c-test: #bbf7d0;
            --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * { box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: var(--font); background: var(--bg-body); color: var(--text-main); overflow: hidden; }

        .hidden { display: none !important; }
        .layer { position: absolute; inset: 0; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* --- LANDING PAGE STYLES --- */
        #dashboard { 
            z-index: 100; background: var(--bg-body); position: absolute; inset: 0; 
            overflow-y: auto; pointer-events: auto; display: flex; flex-direction: column; align-items: center;
        }
        
        .hero-section {
            text-align: center; padding: 60px 20px 40px; max-width: 800px; width: 100%;
        }
        .app-logo {
            width: 80px; height: 80px; background: linear-gradient(135deg, #bae6fd, #fbcfe8);
            border-radius: 20px; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center;
            font-size: 40px; box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }
        .hero-title {
            font-size: 2.5rem; font-weight: 800; margin-bottom: 15px; color: var(--text-main);
        }
        .hero-sub { color: var(--text-muted); font-size: 1.1rem; line-height: 1.6; margin-bottom: 40px; }

        .role-cards { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-bottom: 60px; width: 100%; max-width: 900px; }
        .role-card {
            background: var(--bg-card); flex: 1; min-width: 280px; max-width: 350px;
            padding: 30px; border-radius: 24px; text-align: center; cursor: pointer;
            border: 1px solid var(--border); transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
            box-shadow: var(--shadow);
        }
        .role-card:hover { transform: translateY(-5px); border-color: var(--primary); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); }
        .role-icon { font-size: 3rem; margin-bottom: 15px; }
        .role-name { font-size: 1.5rem; font-weight: 700; margin-bottom: 10px; color: var(--text-main); }
        .role-desc { color: var(--text-muted); font-size: 0.9rem; }

        .features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; width: 100%; max-width: 900px; padding: 0 20px; margin-bottom: 60px; }
        .feature-item { background: var(--bg-card); padding: 25px; border-radius: 16px; border: 1px solid var(--border); }
        .feat-icon { font-size: 1.5rem; margin-bottom: 10px; color: #fbbf24; }
        .feat-title { font-weight: 600; margin-bottom: 5px; color: var(--text-main); }
        .feat-text { color: var(--text-muted); font-size: 0.85rem; line-height: 1.5; }

        /* Setup Forms (Inside Dashboard) */
        .setup-container { 
            background: var(--bg-card); padding: 30px; border-radius: 24px; width: 90%; max-width: 400px; 
            text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.1); margin-top: 20px; border: 1px solid var(--border);
        }
        .input-group { margin-bottom: 20px; text-align: left; }
        .input-label { display: block; color: var(--text-muted); font-size: 0.8rem; margin-bottom: 8px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; }
        .styled-input { 
            width: 100%; padding: 14px; background: #f1f5f9; border: 1px solid var(--border); 
            border-radius: 12px; color: var(--text-main); font-size: 1rem; outline: none; transition: border-color 0.2s;
        }
        .styled-input:focus { border-color: var(--primary); background: white; }
        
        .avatar-selector {
            width: 80px; height: 80px; border-radius: 50%; background: #f1f5f9;
            margin: 0 auto 20px; display: flex; align-items: center; justify-content: center;
            font-size: 2.5rem; cursor: pointer; border: 2px solid var(--primary);
            position: relative; transition: transform 0.2s;
        }
        .avatar-selector:hover { transform: scale(1.05); }
        .avatar-selector::after {
            content: 'EDIT'; position: absolute; bottom: -5px; background: var(--primary);
            color: white; font-size: 10px; padding: 2px 8px; border-radius: 10px; font-weight: bold;
        }

        .btn { padding: 14px 20px; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; transition: transform 0.1s; font-size: 1rem; width: 100%; }
        .btn:active { transform: scale(0.96); }
        .btn-primary { background: var(--primary); color: white; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3); }
        .btn-secondary { background: #f1f5f9; color: var(--text-main); margin-top: 10px; border: 1px solid var(--border); }
        .btn-danger { background: #ef4444; color: white; }

        /* --- APP UI --- */
        .teacher-bar { position: absolute; left: 16px; top: 50%; transform: translateY(-50%); background: white; padding: 8px; border-radius: 16px; box-shadow: 0 4px 25px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 8px; pointer-events: auto; z-index: 500; border: 1px solid var(--border); }
        .tool-btn { width: 44px; height: 44px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; cursor: pointer; transition: background 0.1s; position: relative; color: #333; }
        .tool-btn:hover { background: #f1f5f9; }
        .tool-btn::after { content: attr(title); position: absolute; left: 55px; background: #333; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; opacity: 0; pointer-events: none; white-space: nowrap; transition: 0.2s; z-index: 99; }
        .tool-btn:hover::after { opacity: 1; }
        .sep { width: 100%; height: 1px; background: #e2e8f0; margin: 2px 0; }
        
        .template-popover { position: absolute; left: 58px; top: -100px; background: white; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); padding: 8px; display: flex; flex-direction: column; gap: 6px; animation: fadeIn 0.1s; max-height: 300px; overflow-y: auto; width: 180px; border: 1px solid var(--border); }
        .template-btn { background: none; border: none; padding: 8px 12px; font-size: 0.9rem; text-align: left; border-radius: 8px; cursor: pointer; color: #333; }
        .template-btn:hover { background: #f1f5f9; }
        
        /* Roster Menu */
        .roster-container { position: relative; pointer-events: auto; }
        .roster-btn { padding: 6px 12px; background: white; border: 1px solid var(--border); color: var(--text-main); border-radius: 8px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 6px; height: 32px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .roster-btn:hover { background: #f8fafc; }
        .roster-popover { position: absolute; top: 40px; right: 0; width: 240px; background: white; border-radius: 16px; box-shadow: 0 5px 25px rgba(0,0,0,0.1); padding: 10px; display: flex; flex-direction: column; gap: 6px; z-index: 2000; animation: fadeIn 0.1s; max-height: 400px; overflow-y: auto; color: #333; border: 1px solid var(--border); }
        .user-row { display: flex; align-items: center; justify-content: space-between; font-size: 0.85rem; padding: 8px; border-radius: 8px; }
        .user-row:hover { background: #f1f5f9; }
        .promote-btn { background: #e2e8f0; border: none; color: #333; font-weight: 600; cursor: pointer; font-size: 0.7rem; padding: 4px 8px; border-radius: 6px; }
        .promote-btn.active { background: var(--primary); color: white; }
        .kick-btn { background: #fee2e2; color: #ef4444; border: none; font-weight: 600; cursor: pointer; font-size: 0.7rem; padding: 4px 8px; border-radius: 6px; margin-left: 5px; }

        /* CONTEXT TOOLBAR STYLES */
        .ctx-toolbar-wrapper { display: flex; justify-content: center; align-items: center; width: 100%; pointer-events: auto; }
        .ctx-toolbar { display: flex; gap: 5px; background: white; padding: 4px; border-radius: 8px; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border: 1px solid var(--border); }
        .ctx-btn { background: transparent; border: none; color: var(--text-main); padding: 4px 10px; border-radius: 6px; font-weight: 500; cursor: pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 6px; white-space: nowrap; transition: background 0.1s; height: 24px; }
        .ctx-btn:hover { background: #f1f5f9; }
        .ctx-btn.active { background: var(--primary); color: white; }
        .ctx-btn.stop { background: #ef4444; color: white; }

        .zone-picker-popover { position: absolute; top: 110%; left: 0; background: white; border-radius: 12px; padding: 6px; display: flex; flex-direction: column; gap: 4px; box-shadow: 0 5px 25px rgba(0,0,0,0.1); min-width: 200px; max-height: 250px; overflow-y: auto; z-index: 9100; border: 1px solid var(--border); }
        .zone-picker-item { padding: 10px; border-radius: 8px; cursor: pointer; color: #333; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .zone-picker-item:hover { background: #f1f5f9; }
        .zone-picker-new { border-top: 1px solid #eee; margin-top: 4px; font-weight: 600; color: var(--primary); }

        /* Timer UI */
        .timer-display { position: relative; background: white; color: var(--text-main); padding: 0 16px; border-radius: 8px; font-weight: 700; font-family: monospace; font-size: 1.2rem; display: flex; gap: 10px; align-items: center; cursor: pointer; pointer-events: auto; height: 32px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); border: 1px solid var(--border); }
        .timer-display.urgent { animation: pulse-bg 1s infinite; background: #fee2e2; color: #ef4444; }
        .timer-controls { position: absolute; top: 45px; left: 50%; transform: translateX(-50%); background: white; padding: 10px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); display: flex; gap: 5px; animation: fadeIn 0.1s; z-index: 601; pointer-events: auto; border: 1px solid var(--border); }
        .timer-btn { background: #f1f5f9; border: none; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; color: #333; }
        .timer-close { background: transparent; color: #999; border: none; font-size: 0.8rem; cursor: pointer; margin-left: 5px; padding: 0 5px; }
        @keyframes pulse-bg { 0% { background-color: #fee2e2; } 50% { background-color: #fecaca; } 100% { background-color: #fee2e2; } }

        /* Student View */
        #student-view { position: fixed; inset: 0; background: #f8fafc; color: #1e293b; z-index: 200; display: flex; flex-direction: column; align-items: center; padding: 20px; overflow-y: auto; }
        .student-header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; }
        .conn-badge { padding: 4px 10px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; display: flex; align-items: center; gap: 6px; background: #e2e8f0; color: #64748b; }
        .conn-badge.connected { background: #dcfce7; color: #166534; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: currentColor; }
        
        .student-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 400px; }
        .note-card { background: white; padding: 25px 10px; border-radius: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 10px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.05); transition: transform 0.1s; border: 1px solid var(--border); }
        .note-card:active { transform: scale(0.95); }
        
        .activity-card { background: white; border-radius: 12px; padding: 15px; margin-bottom: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); width: 100%; max-width: 500px; text-align: left; display: flex; align-items: center; gap: 10px; color: #333; border: 1px solid var(--border); }
        .activity-card.selected { border: 2px solid var(--primary); background: #eef2ff; }
        .rank-badge { width: 30px; height: 30px; background: #eee; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
        .board-locked-msg { text-align: center; padding: 40px 20px; }
        .board-locked-msg .icon { font-size: 3rem; margin-bottom: 15px; }

        /* Modals */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(2px); z-index: 3000; display: flex; align-items: center; justify-content: center; pointer-events: auto; }
        .modal-box { background: white; width: 90%; max-width: 400px; padding: 25px; border-radius: 24px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.1); color: #333; border: 1px solid var(--border); }
        .avatar-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 15px; }
        .avatar-opt { font-size: 2rem; cursor: pointer; padding: 5px; border-radius: 8px; transition: transform 0.1s; }
        .avatar-opt:hover { background: #f1f5f9; transform: scale(1.1); }
        
        textarea { width: 100%; height: 120px; border: 1px solid #cbd5e1; border-radius: 12px; padding: 15px; font-family: inherit; font-size: 1rem; resize: none; margin: 15px 0; background: #f8fafc; color: #333; }
        textarea:focus { outline: 2px solid var(--primary); background: white; }

        /* Toast */
        #toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-200%); background: #1e293b; color: white; padding: 12px 24px; border-radius: 30px; transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 9999; font-weight: 500; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        #toast.visible { transform: translateX(-50%) translateY(0); }

        .recent-list { margin-top: 15px; text-align: left; max-height: 150px; overflow-y: auto; }
        .recent-item { padding: 10px; border-bottom: 1px solid var(--border); cursor: pointer; color: var(--text-muted); font-size: 0.9rem; display: flex; justify-content: space-between; }
        .recent-item:hover { background: #f1f5f9; color: var(--primary); }

        @keyframes slideUp { from{transform:translateY(10px);opacity:0} to{transform:translateY(0);opacity:1} }
        @keyframes fadeIn { from{opacity:0} to{opacity:1} }
        
        @media (max-width: 640px) {
            .hero-title { font-size: 2rem; }
            .hero-sub { font-size: 1rem; }
            .role-cards { flex-direction: column; align-items: center; }
            .role-card { width: 90%; max-width: none; }
        }
    </style>
</head>
<body>

<div id="dashboard" class="layer">
    <div id="landing-hero" class="hero-section">
        <div class="app-logo">‚ùì</div>
        <h1 class="hero-title">InquiryDQB</h1>
        <p class="hero-sub">A Digital Question Board that respects your privacy.<br>No accounts. No servers. Zero overhead.</p>

        <div class="role-cards">
            <div class="role-card" onclick="App.setRole('teacher')">
                <div class="role-icon">üë®‚Äçüè´</div>
                <div class="role-name">I'm a Teacher</div>
                <div class="role-desc">Launch a session, create activities, and guide student learning.</div>
            </div>
            <div class="role-card" onclick="App.setRole('student')">
                <div class="role-icon">üéì</div>
                <div class="role-name">I'm a Student</div>
                <div class="role-desc">Join your class, contribute ideas, and collaborate with peers.</div>
            </div>
        </div>

        <div class="features-grid">
            <div class="feature-item">
                <div class="feat-icon">‚ö°Ô∏è</div>
                <div class="feat-title">Instant Setup</div>
                <div class="feat-text">Runs directly in the browser. Just click start and share the link.</div>
            </div>
            <div class="feature-item">
                <div class="feat-icon">üõ°Ô∏è</div>
                <div class="feat-title">Privacy First</div>
                <div class="feat-text">Peer-to-peer technology. Data never leaves your devices.</div>
            </div>
            <div class="feature-item">
                <div class="feat-icon">‚òÅÔ∏è</div>
                <div class="feat-title">Zero Overhead</div>
                <div class="feat-text">No sign-ups or software to install. Works on any device.</div>
            </div>
        </div>
        
        <div style="color: #64748b; font-size: 0.8rem; margin-top: 40px;">¬© 2025 InquiryDQB. All rights reserved.</div>
    </div>

    <div id="setup-panel" class="setup-container hidden">
        <h2 style="margin: 0 0 20px; color: var(--text-main);">Setup Profile</h2>
        <div class="avatar-selector" id="current-avatar" onclick="App.ui.openAvatarModal()">üê∂</div>
        <div class="input-group">
            <label class="input-label">Display Name</label>
            <input type="text" id="username" class="styled-input" placeholder="Your Name">
        </div>
        <div id="student-ops" class="hidden">
            <div class="input-group">
                <label class="input-label">Class ID</label>
                <input type="text" id="join-id" class="styled-input" placeholder="Enter Code" style="font-family: monospace; letter-spacing: 2px;">
            </div>
            <button class="btn btn-primary" onclick="App.start()">Join Class</button>
            <button class="btn btn-secondary" onclick="App.scanQR()">üì∑ Scan QR</button>
        </div>
        <div id="teacher-ops" class="hidden">
            <button class="btn btn-primary" onclick="App.start()">Start New Class</button>
            <div class="recent-list" id="recent-list"></div>
        </div>
        <button class="btn" style="background: transparent; color: #94a3b8; margin-top: 15px;" onclick="App.reset()">Back</button>
    </div>
</div>

<div id="workspace" class="layer hidden pointer-events-auto"></div>
<div id="toast"></div>

<!-- Modals -->
<div id="modal-share" class="modal-overlay hidden">
    <div class="modal-box">
        <h3>Join Class</h3>
        <canvas id="qr-canvas"></canvas>
        <p id="share-id" style="font-family:monospace; background:#f2f2f7; padding:10px; border-radius:8px; user-select: text; margin: 10px 0;"></p>
        <button class="btn btn-primary" style="width:100%; margin-top:5px" onclick="App.ui.copyLink()">üîó Copy Link</button>
        <button class="btn" style="width:100%; margin-top:10px; background: #eee; color: #333;" onclick="App.ui.closeModals()">Close</button>
    </div>
</div>

<div id="modal-scan" class="modal-overlay hidden">
    <div class="modal-box">
        <h3>Scan QR</h3>
        <div id="reader" style="width:100%"></div>
        <button class="btn" style="width:100%; margin-top:10px; background: #eee; color: #333;" onclick="App.stopScan()">Close</button>
    </div>
</div>

<div id="modal-avatars" class="modal-overlay hidden">
    <div class="modal-box">
        <h3>Choose Avatar</h3>
        <div class="avatar-grid" id="avatar-list"></div>
        <button class="btn" style="width:100%; margin-top:20px; background: #eee; color: #333;" onclick="App.ui.closeModals()">Cancel</button>
    </div>
</div>

<script type="module">
    import React, { useState, useEffect, useRef, useMemo } from 'react';
    import { createRoot } from 'react-dom/client';
    import { Tldraw, createTLStore, defaultShapeUtils, getSnapshot, uniqueId, loadSnapshot, createShapeId, track, useEditor, throttle } from 'tldraw';
    import { Peer } from 'peerjs';

    // --- CONFIG ---
    const AVATARS = ['üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ','ü¶Å','üêÆ','üê∑','üê∏','üêµ','üêî','ü¶Ñ','üêù','üêû','üê¢'];
    const NOTES = {
        NOTICE: { color: 'light-blue', hex: '#bae6fd' }, WONDER: { color: 'light-red', hex: '#fbcfe8' },
        IDEA:   { color: 'light-violet', hex: '#e9d5ff' }, TEST:   { color: 'light-green', hex: '#bbf7d0' }
    };
    const HEARTBEAT_INTERVAL = 4000;
    const RECONNECT_TIMEOUT = 5000;

    const DB = {
        async init() { return new Promise(r => { const q = indexedDB.open('DQB_Final_Ult', 1); q.onupgradeneeded=e=>e.target.result.createObjectStore('b',{keyPath:'id'}); q.onsuccess=e=>r(e.target.result); }); },
        async save(id, snap) { const db=await this.init(); db.transaction('b','readwrite').objectStore('b').put({id, snap, d:Date.now()}); },
        async list() { const db=await this.init(); return new Promise(r=>{ const q=db.transaction('b','readonly').objectStore('b').getAll(); q.onsuccess=()=>r(q.result.sort((a,b)=>b.d-a.d)); }); }
    };

    // --- COMPONENTS ---

    function Modal({ isOpen, title, onClose, children }) {
        if (!isOpen) return null;
        return React.createElement('div', { className: 'modal-overlay' },
            React.createElement('div', { className: 'modal-box' },
                React.createElement('h3', null, title),
                children,
                React.createElement('button', { className: 'btn', style:{marginTop:15, background:'#e5e5ea', color:'#333'}, onClick: onClose }, 'Close')
            )
        );
    }

    function TimerDisplay({ state, onUpdate, isTeacher }) {
        const [display, setDisplay] = useState("0:00");
        const [isUrgent, setIsUrgent] = useState(false);
        const [showControls, setShowControls] = useState(false);

        useEffect(() => {
            const tick = () => {
                if (!state.endTime) {
                    setDisplay("0:00");
                    setIsUrgent(false);
                    return;
                }
                
                let diff = state.endTime - (state.pausedAt ? state.pausedAt : Date.now());
                if (state.pausedAt) diff = state.endTime - state.pausedAt;
                if (diff < 0) diff = 0;
                
                const m = Math.floor(diff / 60000);
                const s = Math.floor((diff % 60000) / 1000);
                setDisplay(`${m}:${s.toString().padStart(2, '0')}`);
                setIsUrgent((diff > 0 && diff < 10000) || diff === 0); 
            };
            
            tick();
            const i = setInterval(tick, 250);
            return () => clearInterval(i);
        }, [state]);

        if (!state.endTime && !isTeacher) return null;
        if (!state.endTime && isTeacher) return null;

        return React.createElement('div', { style: {position:'relative'} },
            React.createElement('div', { 
                className: `timer-display ${isUrgent ? 'urgent' : ''}`, 
                onClick: () => isTeacher && setShowControls(!showControls) 
            }, 
                '‚è±Ô∏è', display,
                isTeacher && React.createElement('button', { className: 'timer-close', onClick: (e) => { e.stopPropagation(); onUpdate('STOP'); } }, '‚ùå')
            ),
            showControls && isTeacher && React.createElement('div', { className: 'timer-controls' },
                !state.pausedAt && state.endTime > Date.now() && React.createElement('button', { className: 'timer-btn', onClick: () => onUpdate('PAUSE') }, '‚è∏'),
                state.pausedAt && React.createElement('button', { className: 'timer-btn', onClick: () => onUpdate('RESUME') }, '‚ñ∂Ô∏è'),
                React.createElement('button', { className: 'timer-btn', onClick: () => { onUpdate('STOP'); setShowControls(false); } }, '‚èπ'),
                React.createElement('button', { className: 'timer-btn', onClick: () => { onUpdate('SET'); setShowControls(false); } }, 'Set')
            )
        );
    }

    const ContextToolbar = track(({ editor, magnetId, setMagnetId, activeActivity, startActivity, stopActivity }) => {
        const selectedIds = editor.getSelectedShapeIds();
        if (selectedIds.length === 0) return null;

        const [showMoveMenu, setShowMoveMenu] = useState(false);

        const selShapes = selectedIds.map(id => editor.getShape(id)).filter(Boolean);
        const onlyZone = selShapes.length === 1 && selShapes[0].type === 'frame' ? selShapes[0] : null;
        const onlyItems = selShapes.every(s => s.type !== 'frame') ? selShapes : null;

        if (!onlyZone && !onlyItems) return null;

        const isMagnet = onlyZone && magnetId === onlyZone.id;
        const isActive = onlyZone && activeActivity && activeActivity.zoneId === onlyZone.id;

        const trigger = (type) => {
            if(!onlyZone) return;
            const items = editor.store.allRecords()
                .filter(r => r.typeName==='shape' && r.parentId===onlyZone.id && r.type==='note')
                .map(r => ({ id: r.id, text: r.props.text }));
            if(items.length === 0) return App.ui.toast("Zone has no notes!");
            startActivity(type, onlyZone.id, items);
        };

        const moveTo = (targetId) => {
            if (targetId === 'NEW') {
                const bounds = editor.getSelectionPageBounds();
                const fid = createShapeId();
                editor.createShape({ id: fid, type: 'frame', x: bounds.x - 20, y: bounds.y - 60, props: { w: 400, h: 400, name: 'New Zone' } });
                editor.reparentShapes(selectedIds, fid);
            } else {
                editor.reparentShapes(selectedIds, targetId);
            }
            setShowMoveMenu(false);
            App.ui.toast("Moved!");
        };

        const getZones = () => {
            return Array.from(editor.getCurrentPageShapeIds())
                .map(id => editor.getShape(id))
                .filter(s => s.type === 'frame')
                .map(s => ({ id: s.id, name: s.props.name }));
        };

        return React.createElement('div', { className: 'ctx-toolbar-wrapper' },
            React.createElement('div', { className: 'ctx-toolbar' },
                onlyZone && isActive && React.createElement('button', { className: 'ctx-btn stop', onClick: stopActivity }, '‚èπ Stop Activity'),
                onlyZone && !isActive && React.createElement(React.Fragment, null,
                    React.createElement('span', {style:{color:'#94a3b8',fontSize:'0.7rem',marginRight:5}}, onlyZone.props.name),
                    React.createElement('div', {className:'sep',style:{height:20,width:1,background:'#e2e8f0'}}),
                    React.createElement('button', { className: `ctx-btn ${isMagnet?'active':''}`, onClick:()=>setMagnetId(isMagnet?null:onlyZone.id) }, 'üß≤'),
                    React.createElement('button', { className: 'ctx-btn', onClick: ()=>trigger('VOTE') }, 'üó≥Ô∏è Vote'),
                    React.createElement('button', { className: 'ctx-btn', onClick: ()=>trigger('DISCUSS') }, 'üí¨ Discuss'),
                    React.createElement('button', { className: 'ctx-btn', onClick: ()=>trigger('RANK') }, 'üìä Rank')
                ),
                onlyItems && React.createElement(React.Fragment, null,
                    React.createElement('span', {style:{color:'#94a3b8',fontSize:'0.7rem',marginRight:5}}, `${onlyItems.length} Selected`),
                    React.createElement('div', {className:'sep',style:{height:20,width:1,background:'#e2e8f0'}}),
                    React.createElement('div', { style:{position:'relative'} },
                        React.createElement('button', { className: 'ctx-btn', onClick:()=>setShowMoveMenu(!showMoveMenu) }, '‚û° Move to Zone'),
                        showMoveMenu && React.createElement('div', { className: 'zone-picker-popover' },
                            getZones().map(z => 
                                React.createElement('div', { key: z.id, className: 'zone-picker-item', onClick: ()=>moveTo(z.id) }, 
                                    React.createElement('span', null, '‚¨ú'), z.name
                                )
                            ),
                            React.createElement('div', { className: 'zone-picker-item zone-picker-new', onClick: ()=>moveTo('NEW') }, '‚ûï Create New Zone')
                        )
                    )
                )
            )
        );
    });

    function StudentInputView({ onSend, activity, onActivityResponse, isConnected, isBoardLocked, timerState, onRaiseHand, isHandRaised }) {
        const [modal, setModal] = useState(null);
        const [text, setText] = useState('');
        const [votes, setVotes] = useState(new Set());

        useEffect(() => { setVotes(new Set()); }, [activity?.id]);

        const Header = () => React.createElement('div', { className: 'student-header' },
            React.createElement('div', { style: {display:'flex', gap:10, alignItems:'center'} }, 
                React.createElement('h2', {style:{margin:0}}, 'InquiryDQB'),
                React.createElement('button', { 
                    className: 'btn', 
                    style: { padding: '4px 10px', fontSize: '0.8rem', background: isHandRaised ? '#fbbf24' : '#e5e5ea', color: isHandRaised ? '#000' : '#333' },
                    onClick: onRaiseHand 
                }, isHandRaised ? '‚úã Hand Raised' : '‚úã Raise Hand')
            ),
            React.createElement('div', { className: `conn-badge ${isConnected?'connected':''}` },
                React.createElement('div', { className: 'dot' }),
                isConnected ? 'Online' : 'Reconnecting...'
            )
        );

        if (activity) {
            if (activity.type === 'VOTE') {
                const toggle = (id) => {
                    const next = new Set(votes);
                    if(next.has(id)) next.delete(id); else next.add(id);
                    setVotes(next);
                    onActivityResponse({ activityId: activity.id, votes: Array.from(next) });
                };
                return React.createElement('div', { id: 'student-view' },
                    React.createElement(TimerDisplay, { state: timerState, isTeacher: false }),
                    React.createElement(Header),
                    React.createElement('h2', null, 'üó≥Ô∏è Vote for Notes'),
                    React.createElement('p', null, 'Tap items to vote. Teacher will tally results.'),
                    activity.items.map(item => 
                        React.createElement('div', { 
                            key: item.id, 
                            className: `activity-card ${votes.has(item.id)?'selected':''}`,
                            onClick: () => toggle(item.id)
                        }, item.text)
                    )
                );
            }
        }

        const submit = () => { if(text.trim()) { onSend({type:'post-note',variant:modal,text}); setModal(null); setText(''); App.ui.toast("Sent!"); } };
        
        return React.createElement('div', { id: 'student-view' },
            React.createElement(TimerDisplay, { state: timerState, isTeacher: false }),
            React.createElement(Header),
            isBoardLocked 
            ? React.createElement('div', { className: 'board-locked-msg' },
                React.createElement('div', { className: 'icon' }, 'üîí'),
                React.createElement('h3', null, 'Board Closed'),
                React.createElement('p', { style: { color: '#666' } }, 'The teacher has closed the board for new notes. Please wait.')
              )
            : React.createElement(React.Fragment, null,
                React.createElement('div', { style:{marginBottom:30, textAlign:'center'} },
                    React.createElement('p', {style:{color:'#666'}}, 'Tap a card to add a note')
                ),
                React.createElement('div', { className: 'student-grid' },
                    Object.keys(NOTES).map(k=>React.createElement('div',{key:k,className:'note-card',style:{background:NOTES[k].hex},onClick:()=>{setModal(k);setText('');}},
                        React.createElement('div',{style:{fontSize:'2.5rem'}},k==='NOTICE'?'üì¢':k==='WONDER'?'‚ùì':k==='IDEA'?'üí°':'üß™'),
                        React.createElement('h3',null,k)
                    ))
                )
            ),
            React.createElement('button', {className:'btn',style:{marginTop:40, background:'white', color:'#ef4444'},onClick:()=>location.reload()}, 'Leave Class'),
            modal && React.createElement('div', {className:'modal-overlay'},
                React.createElement('div', {className:'modal-box'},
                    React.createElement('h3',null,`Add ${modal}`),
                    React.createElement('textarea',{autoFocus:true,value:text,onChange:e=>setText(e.target.value)}),
                    React.createElement('div',{style:{display:'flex',gap:10}},
                        React.createElement('button',{className:'btn',style:{flex:1, background:'#eee', color:'#333'},onClick:()=>setModal(null)},'Cancel'),
                        React.createElement('button',{className:'btn btn-primary',style:{flex:1},onClick:submit},'Send')
                    )
                )
            )
        );
    }

    function AutoLayoutEngine({ editor }) {
        const isLayingOut = useRef(false);

        useEffect(() => {
            if (!editor) return;

            const runLayout = (frameId) => {
                const frame = editor.getShape(frameId);
                if (!frame) return;

                const PADDING = 20;
                const GAP = 15;
                const MIN_COL_WIDTH = 180; 
                
                // Prevent division by zero or negative widths if zone is squeezed
                const effectiveW = Math.max(frame.props.w, 100); 
                let numCols = Math.floor((effectiveW - PADDING * 2 + GAP) / (MIN_COL_WIDTH + GAP));
                if (numCols < 1) numCols = 1;

                const colWidth = (effectiveW - PADDING * 2 - (numCols - 1) * GAP) / numCols;
                const colBottoms = Array(numCols).fill(PADDING + 60); 
                const updates = [];

                // Use simple stable sort: y then x. 
                // Do NOT use bucket sorting as it causes oscillation loops during layout updates.
                const childIds = editor.getSortedChildIdsForParent(frameId);
                const children = childIds.map(id => editor.getShape(id)).filter(Boolean);

                children.sort((a, b) => {
                    const dy = a.y - b.y;
                    if (Math.abs(dy) > 10) return dy; // Tolerance for sort stability
                    return a.x - b.x;
                });

                children.forEach(shape => {
                    const geo = editor.getShapeGeometry(shape);
                    const shapeH = geo.bounds.h;
                    const shapeW = geo.bounds.w;

                    let span = Math.ceil((shapeW - 10) / (colWidth + GAP));
                    if (span < 1) span = 1;
                    if (span > numCols) span = numCols;

                    let bestCol = 0;
                    let bestY = Infinity;

                    for (let i = 0; i <= numCols - span; i++) {
                        let maxYInSpan = 0;
                        for (let k = 0; k < span; k++) {
                            if (colBottoms[i + k] > maxYInSpan) maxYInSpan = colBottoms[i + k];
                        }
                        if (maxYInSpan < bestY) {
                            bestY = maxYInSpan;
                            bestCol = i;
                        }
                    }

                    const newX = PADDING + bestCol * (colWidth + GAP);
                    const newY = bestY;
                    
                    if (Math.abs(shape.x - newX) > 1 || Math.abs(shape.y - newY) > 1) {
                         updates.push({ id: shape.id, type: shape.type, x: newX, y: newY });
                    }
                    
                    for (let k = 0; k < span; k++) {
                        colBottoms[bestCol + k] = newY + shapeH + GAP;
                    }
                });

                if (updates.length > 0) {
                    isLayingOut.current = true;
                    editor.updateShapes(updates);
                    setTimeout(() => isLayingOut.current = false, 50);
                }

                const totalH = Math.max(...colBottoms) + PADDING;
                // Only resize if content overflows the current frame height
                if (totalH > frame.props.h) {
                    isLayingOut.current = true;
                    editor.updateShapes([{ id: frameId, type: 'frame', props: { h: totalH } }]);
                    setTimeout(() => isLayingOut.current = false, 50);
                }
            };

            const handleEvent = throttle((event) => {
                if (event.name === 'pointer_up') {
                    const selIds = editor.getSelectedShapeIds();
                    if (selIds.length === 0) return;

                    const pageId = editor.getCurrentPageId();
                    const frames = Array.from(editor.getCurrentPageShapeIds())
                        .map(id => editor.getShape(id))
                        .filter(s => s.type === 'frame');

                    const framesToUpdate = new Set();

                    selIds.forEach(id => {
                        const shape = editor.getShape(id);
                        if (!shape || shape.type === 'frame') return;

                        const bounds = editor.getShapePageBounds(id);
                        if (!bounds) return;
                        const center = {x: bounds.x + bounds.w/2, y: bounds.y + bounds.h/2};

                        const targetFrame = frames.find(f => {
                            if (f.id === id) return false;
                            const b = editor.getShapePageBounds(f.id);
                            return b && center.x > b.x && center.x < b.maxX && center.y > b.y && center.y < b.maxY;
                        });

                        if (targetFrame) {
                            if(shape.parentId !== targetFrame.id) {
                                editor.reparentShapes([id], targetFrame.id);
                            }
                            framesToUpdate.add(targetFrame.id);
                        } else if (shape.parentId !== pageId) {
                            editor.reparentShapes([id], pageId);
                        }
                    });
                    
                    // Immediately trigger layout after interaction
                    setTimeout(() => framesToUpdate.forEach(fid => runLayout(fid)), 50);
                }
            }, 50);

            const handleStore = throttle((e) => {
                // Prevent infinite loop by ignoring updates caused by layout engine
                if (isLayingOut.current) return;
                
                const framesToUpdate = new Set();
                for (const rec of Object.values(e.changes.updated)) {
                    const [prev, next] = rec;

                    // Check if a frame was resized
                    if (next.type === 'frame') {
                        // Check if dimensions changed
                        if (prev.props.w !== next.props.w || prev.props.h !== next.props.h) {
                            framesToUpdate.add(next.id);
                        }
                    } else if (next.parentId && next.parentId !== 'page') {
                        // Check if item moved inside a frame
                        const parent = editor.getShape(next.parentId);
                        if (parent && parent.type === 'frame') {
                            if (Math.abs(prev.x - next.x) > 1 || Math.abs(prev.y - next.y) > 1) {
                                framesToUpdate.add(next.parentId);
                            }
                        }
                    }
                }
                
                if (framesToUpdate.size > 0) {
                    requestAnimationFrame(() => framesToUpdate.forEach(fid => runLayout(fid)));
                }
            }, 100);
            
            const unsubEvent = editor.on('event', handleEvent);
            const unsubStore = editor.store.listen(handleStore);
            return () => { 
                if (typeof unsubEvent === 'function') unsubEvent(); 
                if (typeof unsubStore === 'function') unsubStore(); 
            };
        }, [editor]);

        return null;
    }

    // Sidebar
    function TeacherToolbar({ editor, boardId, isBoardLocked, toggleBoardLock, openTimerModal, openSnapshotModal }) {
        const [menuOpen, setMenuOpen] = useState(false);

        const findOpenSpace = (groupWidth, groupHeight) => {
            const allBounds = editor.getSelectionPageBounds();
            if (allBounds) {
                return { x: allBounds.maxX + 100, y: allBounds.y };
            }
            const viewport = editor.getViewportPageBounds();
            return { x: viewport.x + viewport.w / 2 - groupWidth / 2, y: viewport.y + viewport.h / 2 - groupHeight / 2 };
        };

        const addZone = () => {
            const { x, y } = findOpenSpace(400, 400);
            editor.createShape({ type: 'frame', x, y, props: { name: 'New Zone', w: 400, h: 400 } });
        };
        
        const addCER = () => {
            const { x, y } = findOpenSpace(920, 500);
            ['Claim','Evidence','Reasoning'].forEach((t, i) => {
                editor.createShape({ parentId: editor.getCurrentPageId(), type: 'frame', x: x + (i*310), y: y, props: { name: t, w: 300, h: 500 } });
            });
            setMenuOpen(false);
        };
        
        const addKWL = () => {
            const { x, y } = findOpenSpace(920, 500);
            ['Know','Wonder','Learn'].forEach((t, i) => {
                editor.createShape({ parentId: editor.getCurrentPageId(), type: 'frame', x: x + (i*310), y: y, props: { name: t, w: 300, h: 500 } });
            });
            setMenuOpen(false);
        };

        const addSTW = () => {
            const { x, y } = findOpenSpace(920, 500);
            ['See','Think','Wonder'].forEach((t, i) => {
                editor.createShape({ parentId: editor.getCurrentPageId(), type: 'frame', x: x + (i*310), y: y, props: { name: t, w: 300, h: 500 } });
            });
            setMenuOpen(false);
        };

        const addCompass = () => {
            const { x, y } = findOpenSpace(800, 800);
            const configs = [
                {n:'North (Need to Know)', dx: 250, dy: 0},
                {n:'South (Suggestions)', dx: 250, dy: 500},
                {n:'East (Excited)', dx: 500, dy: 250},
                {n:'West (Worries)', dx: 0, dy: 250}
            ];
            configs.forEach(c => {
                editor.createShape({ parentId: editor.getCurrentPageId(), type: 'frame', x: x + c.dx, y: y + c.dy, props: { name: c.n, w: 240, h: 240 } });
            });
            setMenuOpen(false);
        };

        const addFrayer = () => {
            const { x, y } = findOpenSpace(800, 800);
            const frames = [
                {n:'Definition', x:0, y:0}, {n:'Characteristics', x:400, y:0},
                {n:'Examples', x:0, y:400}, {n:'Non-Examples', x:400, y:400}
            ];
            frames.forEach(f => {
                editor.createShape({ parentId: editor.getCurrentPageId(), type: 'frame', x: x + f.x, y: y + f.y, props: { name: f.n, w: 390, h: 390 } });
            });
            setMenuOpen(false);
        };

        return React.createElement('div', { className: 'teacher-bar' },
            React.createElement('div', { className: 'tool-btn', onClick: addZone, title: 'Add Zone' }, '‚¨úÔ∏è'),
            React.createElement('div', { className: 'tool-btn', onClick: () => setMenuOpen(!menuOpen), title: 'Templates' }, 'üìÑ',
                menuOpen && React.createElement('div', { className: 'template-popover' },
                    React.createElement('button', { className: 'template-btn', onClick: addCER }, 'üî¨ CER Layout'),
                    React.createElement('button', { className: 'template-btn', onClick: addKWL }, 'üß† KWL Chart'),
                    React.createElement('button', { className: 'template-btn', onClick: addSTW }, 'üëÅÔ∏è See-Think-Wonder'),
                    React.createElement('button', { className: 'template-btn', onClick: addCompass }, 'üß≠ Compass Points'),
                    React.createElement('button', { className: 'template-btn', onClick: addFrayer }, 'Áî∞ Frayer Model')
                )
            ),
            React.createElement('div', { className: 'sep' }),
            React.createElement('div', { className: 'tool-btn', onClick: openTimerModal, title: 'Timer Controls' }, '‚è±Ô∏è'),
            React.createElement('div', { className: 'tool-btn', onClick: toggleBoardLock, title: isBoardLocked ? 'Unlock Board' : 'Lock Board' }, isBoardLocked ? 'üîí' : 'üîì'),
            React.createElement('div', { className: 'tool-btn', onClick: openSnapshotModal, title: 'Snapshot' }, 'üì∏'),
            React.createElement('div', { className: 'sep' }),
            React.createElement('div', { className: 'tool-btn', onClick: ()=>App.ui.share(boardId), title: 'Share' }, 'üì°'),
            React.createElement('div', { className: 'tool-btn', onClick: ()=>location.reload(), title: 'Exit' }, 'üè†')
        );
    }

    function RosterMenu({ connections, onPromote, onKick, raisedHands }) {
        const [open, setOpen] = useState(false);
        const [users, setUsers] = useState([]);
        const [kickTarget, setKickTarget] = useState(null);

        useEffect(() => {
            const i = setInterval(() => {
                setUsers(Array.from(connections.keys()).map(k => ({ 
                    id: k, name: connections.get(k).metadata.name||'Student', isCoHost: connections.get(k).metadata.isCoHost 
                })));
            }, 1000);
            return () => clearInterval(i);
        }, [connections]);

        return React.createElement('div', { className: 'roster-container' },
            React.createElement('button', { className: 'roster-btn', onClick: ()=>setOpen(!open) }, 'üë•', React.createElement('span', null, users.length)),
            open && React.createElement('div', { className: 'roster-popover' },
                users.length===0 ? 'No connections' : users.map(u => React.createElement('div', { key: u.id, className: `user-row ${u.isCoHost?'co-host':''}` },
                    React.createElement('div', {style:{display:'flex',flexDirection:'column'}}, 
                        React.createElement('span',{style:{fontWeight:600}}, u.name, raisedHands.has(u.id) ? ' ‚úã' : ''), 
                        React.createElement('span',{style:{fontSize:'0.7rem'}},u.isCoHost?'Co-Host':'Student')
                    ),
                    React.createElement('div', null,
                        React.createElement('button', { className:`promote-btn ${u.isCoHost?'active':''}`, onClick:()=>onPromote(u.id, !u.isCoHost) }, u.isCoHost?'Demote':'Promote'),
                        React.createElement('button', { className: 'kick-btn', onClick:()=>setKickTarget(u) }, 'Kick')
                    )
                ))
            ),
            React.createElement(Modal, { isOpen: !!kickTarget, title: "Confirm Kick", onClose: ()=>setKickTarget(null) },
                React.createElement('p', null, `Are you sure you want to kick ${kickTarget?.name}?`),
                React.createElement('button', { className: 'btn btn-danger', onClick: ()=> { onKick(kickTarget.id); setKickTarget(null); } }, "Kick User")
            )
        );
    }

    function AppCore({ role, boardId, snap, peerId, myName }) {
        const [store] = useState(() => { const s = createTLStore({ shapeUtils: defaultShapeUtils }); if(snap) loadSnapshot(s, snap); return s; });
        const [editor, setEditor] = useState(null);
        const [isCoHost, setIsCoHost] = useState(role === 'teacher');
        const [magnetId, setMagnetId] = useState(null);
        const [isConnected, setIsConnected] = useState(false);
        const [activity, setActivity] = useState(null);
        const [isBoardLocked, setIsBoardLocked] = useState(false);
        
        const [timerState, setTimerState] = useState({ endTime: null, pausedAt: null, duration: 0 });
        const [raisedHands, setRaisedHands] = useState(new Set());
        const [isHandRaised, setIsHandRaised] = useState(false);
        const [timerModalOpen, setTimerModalOpen] = useState(false);
        const [snapshotModalOpen, setSnapshotModalOpen] = useState(false);
        const [timerInput, setTimerInput] = useState("5");

        const connectionsRef = useRef(new Map());
        const peerRef = useRef(null);
        const lastHeartbeatRef = useRef(Date.now());
        const destroyedRef = useRef(false);

        const overrides = useMemo(() => ({
            contextMenu: (menu, { editor }) => {
                const selected = editor.getSelectedShapeIds();
                if (selected.length > 0) {
                    const zones = Array.from(editor.getCurrentPageShapeIds())
                        .map(id => editor.getShape(id))
                        .filter(s => s.type === 'frame');
                    
                    const zoneGroup = {
                        id: 'send-to-zone',
                        type: 'group',
                        children: [
                            {
                                id: 'new-zone',
                                type: 'item',
                                action: () => {
                                    const bounds = editor.getSelectionPageBounds();
                                    if(bounds) {
                                        const fid = createShapeId();
                                        editor.createShape({ id: fid, type: 'frame', x: bounds.x - 20, y: bounds.y - 60, props: { w: 400, h: 400, name: 'New Zone' } });
                                        editor.reparentShapes(selected, fid);
                                    }
                                },
                                label: 'Create New Zone'
                            },
                            ...zones.map(z => ({
                                id: `zone-${z.id}`,
                                type: 'item',
                                action: () => { 
                                    editor.reparentShapes(selected, z.id); 
                                },
                                label: `Move to ${z.props.name}`
                            }))
                        ],
                        label: 'Send to Zone'
                    };
                    if(Array.isArray(menu)) { menu.unshift(zoneGroup); }
                }
                return menu;
            }
        }), []);
        
        const toggleBoardLock = () => {
            const newState = !isBoardLocked;
            setIsBoardLocked(newState);
            const msg = JSON.stringify({ type: 'BOARD_LOCK_TOGGLE', locked: newState });
            connectionsRef.current.forEach(c => { if(c.open) c.send(msg); });
            App.ui.toast(newState ? "Board Locked" : "Board Unlocked");
        };

        const handleTimerOp = (op, val) => {
            let newState = { ...timerState };
            if (op === 'SET') { setTimerModalOpen(true); return; }
            if (op === 'START') {
                const ms = parseInt(val) * 60 * 1000;
                newState = { endTime: Date.now() + ms, pausedAt: null, duration: ms };
            }
            if (op === 'PAUSE') newState.pausedAt = Date.now();
            if (op === 'RESUME') {
                if (newState.pausedAt) {
                    const pausedDuration = Date.now() - newState.pausedAt;
                    newState.endTime += pausedDuration;
                    newState.pausedAt = null;
                }
            }
            if (op === 'STOP') newState = { endTime: null, pausedAt: null, duration: 0 };

            setTimerState(newState);
            const msg = JSON.stringify({ type: 'TIMER_UPDATE', state: newState });
            connectionsRef.current.forEach(c => { if(c.open) c.send(msg); });
        };

        const handleSnapshot = async (type) => {
            let ids = [];
            let bounds = undefined;
            if (type === 'selection') ids = editor.getSelectedShapeIds();
            else if (type === 'visible') {
                const viewport = editor.getViewportPageBounds();
                const allShapes = editor.getCurrentPageShapeIds();
                ids = Array.from(allShapes).filter(id => {
                    const b = editor.getShapePageBounds(id);
                    return b && b.collides(viewport);
                });
                bounds = viewport; 
            } else ids = Array.from(editor.getCurrentPageShapeIds());

            if (ids.length === 0) return App.ui.toast("Board is empty");

            try {
                const svgElement = await editor.getSvg(ids, { scale: 1, background: true, bounds });
                if(svgElement) { 
                    const svgString = new XMLSerializer().serializeToString(svgElement);
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `DQB_Snapshot_${type}.svg`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    setSnapshotModalOpen(false);
                }
            } catch(e) { console.error(e); App.ui.toast("Snapshot failed"); }
        };

        const handleRaiseHand = () => {
            const newState = !isHandRaised;
            setIsHandRaised(newState);
            if(role === 'student') {
                const c = connectionsRef.current.get(boardId);
                if(c) c.send(JSON.stringify({ type: 'RAISE_HAND', value: newState }));
            }
        };

        const kickUser = (pid) => {
            const c = connectionsRef.current.get(pid);
            if(c) {
                c.send(JSON.stringify({ type: 'KICKED' }));
                setTimeout(() => c.close(), 100);
                connectionsRef.current.delete(pid);
            }
        };

        const startActivity = (type, zoneId, items) => {
            const newActivity = { id: uniqueId(), type, zoneId, items, responses: new Map() };
            setActivity(newActivity);
            const msg = JSON.stringify({ type: 'START_ACTIVITY', activity: { id: newActivity.id, type, zoneId, items } });
            connectionsRef.current.forEach(c => { if(c.open) c.send(msg); });
            App.ui.toast(`${type} started for students`);
        };

        const stopActivity = () => {
            if (!activity || !editor) return;
            const { type, zoneId, responses } = activity;
            if (type === 'VOTE') {
                const counts = {};
                responses.forEach((data) => { data.votes.forEach(noteId => counts[noteId] = (counts[noteId]||0) + 1); });
                const stickers = [];
                Object.entries(counts).forEach(([noteId, count]) => {
                    const note = editor.getShape(noteId);
                    if(note && count > 0) {
                        stickers.push({
                            id: createShapeId(), type: 'text', x: note.x + note.props.w -10, y: note.y - 15, parentId: zoneId,
                            props: { text: `‚ù§Ô∏è ${count}`, scale: 1.5, color: 'red' }
                        });
                    }
                });
                editor.createShapes(stickers);
                App.ui.toast("Votes Tallied!");
            }
            setActivity(null);
            const msg = JSON.stringify({ type: 'STOP_ACTIVITY' });
            connectionsRef.current.forEach(c => { if(c.open) c.send(msg); });
        };

        const handleStudentResponse = (peerId, data) => {
            if (!activity || activity.id !== data.activityId) return;
            const newMap = new Map(activity.responses);
            newMap.set(peerId, data);
            setActivity({ ...activity, responses: newMap });
        };

        // --- Robust Connection Logic ---
        useEffect(() => {
            let peerInstance = null;

            const initPeer = () => {
                if (destroyedRef.current) return;
                
                // Destroy old instance if exists to be safe
                if (peerInstance) peerInstance.destroy();

                const peer = new Peer(peerId, { debug: 1 });
                peerInstance = peer;
                peerRef.current = peer;

                peer.on('error', (err) => {
                    console.error("PeerJS Error:", err);
                    if (err.type === 'peer-unavailable') {
                        App.ui.toast("Class ID not found. Please check.");
                        if(role === 'student') setTimeout(()=>location.reload(), 3000);
                    } else if (err.type === 'disconnected' || err.type === 'network' || err.type === 'server-error') {
                        // Critical error, recreate peer
                        console.log("Critical Peer Error, respawning...");
                        setTimeout(initPeer, 2000); 
                    }
                });

                peer.on('disconnected', () => {
                    if(!destroyedRef.current) {
                        console.log("Peer disconnected, attempting reconnect...");
                        peer.reconnect();
                    }
                });

                const handleMsg = (conn, data) => {
                    try {
                        const msg = (typeof data === 'string') ? JSON.parse(data) : data;
                        lastHeartbeatRef.current = Date.now();
                        if(msg.type === 'HEARTBEAT') return;

                        if(role === 'teacher') {
                            if(msg.type === 'post-note' && !isBoardLocked) {
                                if(!editor) return;
                                const pid = magnetId && editor.getShape(magnetId) ? magnetId : editor.getCurrentPageId();
                                editor.createShape({ id: createShapeId(), type: 'note', parentId: pid, x: 20, y: 60, props: { text: msg.text, color: NOTES[msg.variant].color } });
                                App.ui.toast(`Note received`);
                            }
                            if(msg.type === 'ACTIVITY_RESPONSE') handleStudentResponse(conn.peer, msg.payload);
                            if(msg.type === 'RAISE_HAND') {
                                setRaisedHands(prev => {
                                    const next = new Set(prev);
                                    if(msg.value) next.add(conn.peer); else next.delete(conn.peer);
                                    return next;
                                });
                            }
                            if(msg.type === 'sync-update') {
                                store.mergeRemoteChanges(() => {
                                    const {added,updated,removed} = msg.changes;
                                    for(let k in added) store.put([added[k]]);
                                    for(let k in updated) store.put([updated[k][1]]);
                                    for(let k in removed) store.remove([removed[k].id]);
                                });
                            }
                        }

                        if(role === 'student') {
                            if(msg.type === 'START_ACTIVITY') setActivity(msg.activity);
                            if(msg.type === 'STOP_ACTIVITY') { setActivity(null); App.ui.toast("Activity Ended"); }
                            if(msg.type === 'promote') { setIsCoHost(msg.value); App.ui.toast(msg.value?"Co-Host Mode":"Student Mode"); }
                            if(msg.type === 'init-sync') loadSnapshot(store, msg.snap);
                            if(msg.type === 'sync-update') {
                                store.mergeRemoteChanges(() => {
                                    const {added,updated,removed} = msg.changes;
                                    for(let k in added) store.put([added[k]]);
                                    for(let k in updated) store.put([updated[k][1]]);
                                    for(let k in removed) store.remove([removed[k].id]);
                                });
                            }
                            if(msg.type === 'BOARD_LOCK_TOGGLE') setIsBoardLocked(msg.locked);
                            if(msg.type === 'TIMER_UPDATE') setTimerState(msg.state);
                            if(msg.type === 'KICKED') {
                                destroyedRef.current = true;
                                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;font-family:sans-serif;flex-direction:column"><h1>Removed</h1><p>You have been removed from the class.</p><button onclick="location.reload()" style="padding:10px 20px">Return Home</button></div>';
                            }
                        }
                    } catch(e){ console.error(e); }
                };

                const setupConnection = (conn) => {
                    conn.on('open', () => {
                        connectionsRef.current.set(conn.peer, conn);
                        setIsConnected(true);
                        if(role === 'teacher') {
                            conn.send(JSON.stringify({ type: 'init-sync', snap: getSnapshot(store) }));
                            conn.send(JSON.stringify({ type: 'BOARD_LOCK_TOGGLE', locked: isBoardLocked }));
                            if(timerState.endTime) conn.send(JSON.stringify({ type: 'TIMER_UPDATE', state: timerState }));
                        }
                    });
                    conn.on('data', d => handleMsg(conn, d));
                    conn.on('close', () => {
                        connectionsRef.current.delete(conn.peer);
                        if(role==='student') setIsConnected(false);
                        if(role==='teacher') {
                            setRaisedHands(prev => {
                                const next = new Set(prev);
                                next.delete(conn.peer);
                                return next;
                            });
                        }
                    });
                };

                peer.on('open', id => { 
                    if(role==='student') {
                         const conn = peer.connect(boardId, { metadata: { name: myName, isCoHost: false }, serialization: 'json' });
                         setupConnection(conn);
                    }
                });
                
                peer.on('connection', c => { if(role==='teacher') setupConnection(c); });
            };

            initPeer();

            const hb = setInterval(() => {
                if (destroyedRef.current) return;

                if(role === 'teacher') {
                    const m = JSON.stringify({ type: 'HEARTBEAT' });
                    connectionsRef.current.forEach(c => c.open && c.send(m));
                } else {
                    if(Date.now() - lastHeartbeatRef.current > RECONNECT_TIMEOUT) {
                        setIsConnected(false);
                        // Force a peer respawn if connection is truly dead
                        if(peerRef.current && !peerRef.current.destroyed && !peerRef.current.disconnected) {
                             // Try simple reconnect first
                             peerRef.current.reconnect();
                        } else {
                             // Peer dead, respawn
                             initPeer();
                        }
                    }
                }
            }, HEARTBEAT_INTERVAL);

            const cleanStore = store.listen(e => {
                if(e.source !== 'user') return;
                if(role === 'student' && !isCoHost) return;
                const changes = {added:{}, updated:{}, removed:{}};
                let has = false;
                const allow = ['shape','asset','instance_presence'];
                const chk = (r, op) => { if(allow.includes(r.typeName)) { if(op==='add')changes.added[r.id]=r; if(op==='rem')changes.removed[r.id]=r; if(op==='upd')changes.updated[r.id]=[null,r]; has=true; } };
                for(let k in e.changes.added) chk(e.changes.added[k], 'add');
                for(let k in e.changes.removed) chk(e.changes.removed[k], 'rem');
                for(let k in e.changes.updated) chk(e.changes.updated[k][1], 'upd');
                if(has) {
                    const msg = JSON.stringify({ type: 'sync-update', changes });
                    if(role === 'teacher') {
                        connectionsRef.current.forEach(c => { if(c.open && c.metadata.isCoHost) c.send(msg); });
                        DB.save(boardId, getSnapshot(store));
                    } else {
                        const host = connectionsRef.current.get(boardId);
                        if(host && host.open) host.send(msg);
                    }
                }
            });

            return () => {
                destroyedRef.current = true;
                if(peerInstance) peerInstance.destroy();
                if (typeof cleanStore === 'function') cleanStore();
                clearInterval(hb);
            };
        }, [isCoHost, magnetId, editor, activity, isBoardLocked, timerState]);

       const promote = (pid, val) => {
            const c = connectionsRef.current.get(pid);
            if(c) {
                c.metadata.isCoHost = val;
                c.send(JSON.stringify({ type: 'promote', value: val }));
                if(val) c.send(JSON.stringify({ type: 'init-sync', snap: getSnapshot(store) }));
            }
        };

        const sendStudentActivityResponse = (payload) => {
            const c = connectionsRef.current.get(boardId);
            if(c) c.send(JSON.stringify({ type: 'ACTIVITY_RESPONSE', payload }));
        };

        const CustomTopPanel = track(() => {
            if (!editor) return null;
            const selectedIds = editor.getSelectedShapeIds();
            if (role === 'teacher' && selectedIds.length > 0) {
                return React.createElement(ContextToolbar, { editor, magnetId, setMagnetId, activeActivity: activity, startActivity, stopActivity });
            }
            return React.createElement(TimerDisplay, { state: timerState, onUpdate: handleTimerOp, isTeacher: true });
        });

        const CustomSharePanel = () => {
            if (role !== 'teacher') return null;
            return React.createElement(RosterMenu, { connections: connectionsRef.current, onPromote: promote, onKick: kickUser, raisedHands });
        };

        if(role === 'student' && !isCoHost) return React.createElement(StudentInputView, { 
            onSend: msg => { const c = connectionsRef.current.get(boardId); if(c) c.send(JSON.stringify(msg)); }, 
            isConnected,
            isBoardLocked,
            activity,
            timerState,
            isHandRaised,
            onRaiseHand: handleRaiseHand,
            onActivityResponse: sendStudentActivityResponse
        });

        return React.createElement('div', { className: 'layer pointer-events-auto' },
            React.createElement(Tldraw, {
                store,
                overrides,
                onMount: e => { setEditor(e); e.user.updateUserPreferences({ name: myName }); },
                components: {
                    TopPanel: CustomTopPanel,
                    SharePanel: CustomSharePanel,
                    InFrontOfTheCanvas: () => React.createElement('div', { className: 'layer pointer-events-none' },
                        role==='teacher' && editor && React.createElement(TeacherToolbar, { 
                            editor, boardId, isBoardLocked, toggleBoardLock, 
                            openTimerModal: ()=>setTimerModalOpen(true),
                            openSnapshotModal: ()=>setSnapshotModalOpen(true)
                        }),
                        role==='teacher' && editor && React.createElement(AutoLayoutEngine, { editor })
                    )
                }
            }),
            React.createElement(Modal, { isOpen: timerModalOpen, title: "Set Timer", onClose: ()=>setTimerModalOpen(false) },
                React.createElement('div', { style:{display:'flex', flexDirection:'column', gap:10} },
                    React.createElement('label', null, 'Minutes:'),
                    React.createElement('input', { type:'number', value: timerInput, onChange:e=>setTimerInput(e.target.value), style:{padding:10, fontSize:'1.2rem'} }),
                    React.createElement('button', { className:'btn btn-primary', onClick: () => { handleTimerOp('START', timerInput); setTimerModalOpen(false); } }, 'Start Timer')
                )
            ),
            React.createElement(Modal, { isOpen: snapshotModalOpen, title: "Take Snapshot", onClose: ()=>setSnapshotModalOpen(false) },
                React.createElement('div', { style:{display:'flex', flexDirection:'column', gap:10} },
                    React.createElement('button', { className:'btn', onClick: () => handleSnapshot('whole') }, 'Whole Board'),
                    React.createElement('button', { className:'btn', onClick: () => handleSnapshot('visible') }, 'Visible Area'),
                    React.createElement('button', { 
                        className:'btn', 
                        disabled: editor && editor.getSelectedShapeIds().length === 0,
                        style: { opacity: (editor && editor.getSelectedShapeIds().length === 0) ? 0.5 : 1 },
                        onClick: () => handleSnapshot('selection') 
                    }, 'Selection Only')
                )
            )
        );
    }

    window.App = {
        role: null, avatar: 'üê∂', username: 'Guest',
        init() {
            const a = document.getElementById('avatar-list');
            if(a) { 
                AVATARS.forEach((x)=>{
                    const d=document.createElement('div');
                    d.className='avatar-opt';
                    d.innerText=x;
                    d.onclick=()=>{
                        this.avatar=x;
                        document.getElementById('current-avatar').innerText = x;
                        this.ui.closeModals();
                    };
                    a.appendChild(d);
                }); 
            }
            const p = new URLSearchParams(location.search);
            if(p.get('join')) { this.setRole('student'); document.getElementById('join-id').value = p.get('join'); }
        },
        setRole(r) {
            this.role = r;
            document.getElementById('landing-hero').classList.add('hidden');
            document.getElementById('setup-panel').classList.remove('hidden');
            document.getElementById('teacher-ops').classList.toggle('hidden', r!=='teacher');
            document.getElementById('student-ops').classList.toggle('hidden', r!=='student');
            if(r==='teacher') this.loadRecents();
        },
        reset() {
            this.role = null;
            document.getElementById('landing-hero').classList.remove('hidden');
            document.getElementById('setup-panel').classList.add('hidden');
        },
        async loadRecents() {
            const l = await DB.list();
            const c = document.getElementById('recent-list');
            c.innerHTML = l.length>0?'':'<div style="color:#666; font-size:0.8rem; padding:10px;">No recent boards found.</div>';
            l.forEach(b => { 
                const d=document.createElement('div');
                d.className='recent-item';
                d.innerHTML=`<span>${new Date(b.d).toLocaleDateString()}</span> <span>${b.id.slice(0,5)}...</span>`;
                d.onclick=()=>this.launch(b.id, b.snap);
                c.appendChild(d); 
            });
        },
        start() {
            if(this.role==='student' && !document.getElementById('join-id').value) return alert("Enter ID");
            const id = this.role==='teacher' ? uniqueId() : document.getElementById('join-id').value;
            this.launch(id, null);
        },
        async launch(id, snap) {
            this.username = document.getElementById('username').value || (this.role==='teacher'?'Teacher':'Student');
            document.getElementById('dashboard').classList.add('hidden');
            document.getElementById('workspace').classList.remove('hidden');
            history.replaceState({},'',location.pathname);
            const peerId = this.role === 'teacher' ? id : uniqueId();
            const root = createRoot(document.getElementById('workspace'));
            root.render(React.createElement(AppCore, { role: this.role, boardId: id, snap, peerId, myName: `${this.avatar} ${this.username}` }));
        },
        ui: {
            currentUrl: '',
            share(id) {
                this.currentUrl = `${location.origin}${location.pathname}?join=${id}`;
                QRCode.toCanvas(document.getElementById('qr-canvas'), this.currentUrl, {width:200}, ()=>{});
                document.getElementById('share-id').innerText = id;
                document.getElementById('modal-share').classList.remove('hidden');
            },
            copyLink() {
                if(!this.currentUrl) return;
                navigator.clipboard.writeText(this.currentUrl).then(() => { this.toast("Link Copied! üìã"); }).catch(() => this.toast("Copy Failed"));
            },
            openAvatarModal() { document.getElementById('modal-avatars').classList.remove('hidden'); },
            closeModals() { document.querySelectorAll('.modal-overlay').forEach(m => m.classList.add('hidden')); },
            toast(m) { const t=document.getElementById('toast'); t.innerText=m; t.classList.add('visible'); setTimeout(()=>t.classList.remove('visible'), 2000); }
        },
        scanQR() {
            document.getElementById('modal-scan').classList.remove('hidden');
            this.scanner = new Html5Qrcode("reader");
            this.scanner.start({facingMode:"environment"}, {fps:10, qrbox:250}, (t)=>{ try { const u=new URL(t); const id=u.searchParams.get('join'); if(id){document.getElementById('join-id').value=id;this.stopScan();this.start();} }catch(e){App.ui.toast("Invalid QR");} }, ()=>{});
        },
        stopScan() { if(this.scanner) this.scanner.stop().then(()=>this.scanner.clear()); document.getElementById('modal-scan').classList.add('hidden'); }
    };
    App.init();
</script>
</body>
</html>